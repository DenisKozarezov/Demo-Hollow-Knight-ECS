<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces.Desktop</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.Execution.DesktopReferenceSerializationServiceFactory">
            <summary>
            this is desktop implementation of IReferenceSerializationService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SerializationAnalyzerAssemblyLoader">
            <summary>
            This is assembly loader for serialized analyzer reference. 
            
            this will record display path (<see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/>  returns) and 
            actual path (<see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAssembly"/> ) assembly needed to be loaded 
            
            when requested, it will load from actual path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.TraceLogger">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Internal.Log.ILogger"/> that produce timing debug output. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceDesktopResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_characters_in_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices">
            <summary>
            A class that provides host services via classes instances exported via a MEF version 1 composition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.s_CreationHook">
            <summary>
            This delegate allows test code to override the behavior of <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/>.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreationHook)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreationHook)">
            <summary>
            For test use only. Injects replacement behavior for the <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.SingleFileThreshold">
            <summary>
            The maximum size in bytes of a single storage unit in a memory mapped file which is shared with other
            storage units.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.MultiFileBlockSize">
            <summary>
            The size in bytes of a memory mapped file created to store multiple temporary objects.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate">
            <summary>
            The synchronization object for accessing the memory mapped file related fields (indicated in the remarks
            of each field).
            </summary>
            <remarks>
            <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
            available in source control history. The use of exclusive locks was not causing any measurable
            performance overhead even on 28-thread machines at the time this was written.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference">
            <summary>
            The most recent memory mapped file for creating multiple storage units. It will be used via bump-pointer
            allocation until space is no longer available in it.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._name">
            <summary>The name of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._fileSize">
            <summary>The total size of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._offset">
            <summary>
            The offset into the current memory mapped file where the next storage unit can be held.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.CreateTemporaryStorage(System.Int64)">
            <summary>
            Allocate shared storage of a specified size.
            </summary>
            <remarks>
            <para>"Small" requests are fulfilled from oversized memory mapped files which support several individual
            storage units. Larger requests are allocated in their own memory mapped files.</para>
            </remarks>
            <param name="size">The size of the shared storage block to allocate.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> describing the allocated block.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo">
             <summary>
             Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
             Otherwise, each view has minimum size of 64K due to requirement forced by windows.
             
             most of our view will have short lifetime, but there are cases where view might live a bit longer such as
             metadata dll shadow copy. shared view will help those cases.
             </summary>
             <remarks>
             <para>Instances of this class should be disposed when they are no longer needed. After disposing this
             instance, it should no longer be used. However, streams obtained through <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>
             or <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream"/> will not be invalidated until they are disposed independently (which
             may occur before or after the <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> is disposed.</para>
            
             <para>This class and its nested types have familiar APIs and predictable behavior when used in other code,
             but are non-trivial to work on. The implementations of <see cref="T:System.IDisposable"/> adhere to the best
             practices described in
             <see href="http://joeduffyblog.com/2005/04/08/dg-update-dispose-finalization-and-resource-management/">DG
             Update: Dispose, Finalization, and Resource Management</see>. Additional notes regarding operating system
             behavior leveraged for efficiency are given in comments.</para>
             </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._memoryMappedFile">
            <summary>
            The memory mapped file.
            </summary>
            <remarks>
            <para>It is possible for this accessor to be disposed prior to the view and/or the streams which use it.
            However, the operating system does not actually close the views which are in use until the view handles
            are closed as well, even if the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/> is disposed first.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._weakReadAccessor">
             <summary>
             A weak reference to a read-only view for the memory mapped file.
             </summary>
             <remarks>
             <para>This holds a weak counted reference to current <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor"/>, which
             allows additional accessors for the same address space to be obtained up until the point when no
             external code is using it. When the memory is no longer being used by any
             <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream"/> objects, the view of the memory mapped file is unmapped, making the
             process address space it previously claimed available for other purposes. If/when it is needed again, a
             new view is created.</para>
            
             <para>This view is read-only, so it is only used by <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Name">
            <summary>
            The name of the memory mapped file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Offset">
            <summary>
            The offset into the memory mapped file of the region described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Size">
            <summary>
            The size of the region of the memory mapped file described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.RunWithCompactingGCFallback``2(System.Func{``0,``1},``0)">
            <summary>
            Run a function which may fail with an <see cref="T:System.IO.IOException"/> if not enough memory is available to
            satisfy the request. In this case, a full compacting GC pass is forced and the function is attempted
            again.
            </summary>
            <remarks>
            <para><see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> and
            <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> will use a native
            memory map, which can't trigger a GC. In this case, we'd otherwise crash with OOM, so we don't care
            about creating a UI delay with a full forced compacting GC. If it crashes the second try, it means we're
            legitimately out of resources.</para>
            </remarks>
            <typeparam name="TArg">The type of argument to pass to the callback.</typeparam>
            <typeparam name="T">The type returned by the function.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument">The argument to pass to the function.</param>
            <returns>The value returned by <paramref name="function"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            Get underlying native memory directly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker">
            <summary>
            Track approximate solution size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker.GetSolutionSize(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Get approximate solution size at the point of call.
            
            This API is not supposed to return 100% accurate size. 
            
            if a feature require 100% accurate size, use Solution to calculate it. this API is supposed to
            lazy and very cheap on answering that question.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> that helps ensure that the statement
             is always <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/> after it is used.
             
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection">
            <summary>
            Encapsulates a connection to a sqlite database.  On construction an attempt will be made
            to open the DB if it exists, or create it if it does not.
            
            Connections are considered relatively heavyweight and are pooled until the <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage"/>
            is <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Dispose"/>d.  Connections can be used by different threads,
            but only as long as they are used by one thread at a time.  They are not safe for concurrent
            use by several threads.
            
            <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be created through the user of <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.GetResettableStatement(System.String)"/>.
            These statements are cached for the lifetime of the connection and are only finalized
            (i.e. destroyed) when the connection is closed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._handle">
            <summary>
            The raw handle to the underlying DB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._faultInjector">
            <summary>
            For testing purposes to simulate failures during testing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._queryToStatement">
            <summary>
            Our cache of prepared statements for given sql strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.IsInTransaction">
            <summary>
            Whether or not we're in a transaction.  We currently don't supported nested transactions.
            If we want that, we can achieve it through sqlite "save points".  However, that's adds a 
            lot of complexity that is nice to avoid.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).  
            
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.
            
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Close_OnlyForUseBySqlPersistentStorage"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> backed by SQLite.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3">
            <summary>
            Abstracts out access to specific tables in the DB.  This allows us to share overall
            logic around cancellation/pooling/error-handling/etc, while still hitting different
            db tables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWrites">
            <summary>
            Queue of actions we want to perform all at once against the DB in a single transaction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWriteTask">
            <summary>
            The task responsible for writing out all the batched actions we have for a particular
            queue.  When new reads come in for that queue they can 'await' this write-task completing
            so that all reads for the queue observe any previously completed writes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.StringInfoTableName">
            <summary>
            Inside the DB we have a table dedicated to storing strings that also provides a unique 
            integral ID per string.  This allows us to store data keyed in a much more efficient
            manner as we can use those IDs instead of duplicating strings all over the place.  For
            example, there may be many pieces of data associated with a file.  We don't want to 
            key off the file path in all these places as that would cause a large amount of bloat.
            
            Because the string table can map from arbitrary strings to unique IDs, it can also be
            used to create IDs for compound objects.  For example, given the IDs for the FilePath
            and Name of a Project, we can get an ID that represents the project itself by just
            creating a compound key of those two IDs.  This ID can then be used in other compound
            situations.  For example, a Document's ID is creating by compounding its Project's 
            ID, along with the IDs for the Document's FilePath and Name.
            
            The format of the table is:
            
             StringInfo
             --------------------------------------------------------------
             | Id (integer, primary key, auto increment) | Data (varchar) |
             --------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName">
            <summary>
            Inside the DB we have a table for data corresponding to the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.  The 
            data is just a blob that is keyed by a string Id.  Data with this ID can be retrieved
            or overwritten.
            
            The format of the table is:
            
             SolutionData
             -----------------------------------------------
             | DataId (primary key, varchar) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            The data is keyed off of an integral value produced by combining the ID of the Project and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             ProjectData
             -----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            The data is keyed off of an integral value produced by combining the ID of the Document and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             DocumentData
             ----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             ----------------------------------------------
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.GetPooledConnection">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection"/> from the connection pool, or creates one if none are available.
            </summary>
            <remarks>
            Database connections have a large amount of overhead, and should be returned to the pool when they are no
            longer in use. In particular, make sure to avoid letting a connection lease cross an <see langword="await"/>
            boundary, as it will prevent code in the asynchronous operation from using the existing connection.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateIds(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Solution,System.Boolean)">
            <remarks>
            We have a lot of ID information to put into the DB. IDs for all strings we intend to 
            intern, as well as compound IDs for our projects and documents. Inserting these 
            individually is far too slow as SQLite will lock the DB for each insert and will have
            to do all the journalling work to ensure ACID semantics.  To avoid that, we attempt
            to precompute all the information we'd need to put in the ID tables and perform it
            all at once per project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateProjectIdsWorker(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns 'true' if the bulk population succeeds, or false if it doesn't.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._documentIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a document, to the ID we use in the DB for the document.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetDocumentDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Document,System.String,System.Int64@)">
            <summary>
            Given a document, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the DocumentData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.FlushAllDelayMS">
            <summary>
            Amount of time to wait between flushing writes to disk.  500ms means we can flush
            writes to disk two times a second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrayLength">
            <summary>
            We use a pool to cache reads/writes that are less than 4k.  Testing with Roslyn,
            99% of all writes (48.5k out of 49.5k) are less than that size.  So this helps
            ensure that we can pool as much as possible, without caching excessively large 
            arrays (for example, Roslyn does write out nearly 50 chunks that are larger than
            100k each).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrays">
            <summary>
            The max amount of byte[]s we cache.  This caps our cache at 4MB while allowing
            us to massively speed up writing (by batching writes).  Because we can write to
            disk two times a second.  That means a total of 8MB/s that can be written to disk
            using only our cache.  Given that Roslyn itself only writes about 50MB to disk
            after several minutes of analysis, this amount of bandwidth is more than sufficient.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._projectIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a project, to the ID we use in the DB for the project.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetProjectDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project,System.String,System.Int64@)">
            <summary>
            Given a project, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the ProjectData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._writeQueueGate">
            <summary>
            Lock protecting the write queues and <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask">
            <summary>
            Task kicked off to actually do the work of flushing all data to the DB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService._lock">
            <summary>
            This lock guards all mutable fields in this type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService.PersistentStorageReferenceCountedDisposableWrapper">
            <summary>
            A trivial wrapper that we can hand out for instances from the <see cref="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService"/>
            that wraps the underlying <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> singleton.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.StorageOptions.SolutionSizeThreshold">
            <summary>
            Solution size threshold to start to use a DB (Default: 50MB)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopAnalyzerAssemblyLoader">
            <summary>
            Loads analyzer assemblies from their original locations in the file system.
            Assemblies will only be loaded from the locations specified when the loader
            is instantiated.
            </summary>
            <remarks>
            This type is meant to be used in scenarios where it is OK for the analyzer
            assemblies to be locked on disk for the lifetime of the host; for example,
            csc.exe and vbc.exe. In scenarios where support for updating or deleting
            the analyzer on disk is required a different loader should be used.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
    </members>
</doc>
